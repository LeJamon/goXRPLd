package pseudo

import (
	"errors"
	"github.com/LeJamon/goXRPLd/internal/core/tx"

	"github.com/LeJamon/goXRPLd/internal/core/ledger/keylet"
	"github.com/LeJamon/goXRPLd/internal/core/tx/sle"
)

func init() {
	tx.Register(tx.TypeFee, func() tx.Transaction {
		return &SetFee{BaseTx: *tx.NewBaseTx(tx.TypeFee, "")}
	})
}

// SetFee errors matching rippled
var (
	ErrSetFeeBadSrcAccount = errors.New("temBAD_SRC_ACCOUNT: SetFee must have zero account")
	ErrSetFeeBadFee        = errors.New("temBAD_FEE: SetFee must have zero fee")
	ErrSetFeeBadSignature  = errors.New("temBAD_SIGNATURE: SetFee must not have signature")
	ErrSetFeeBadSequence   = errors.New("temBAD_SEQUENCE: SetFee must have zero sequence")
	ErrSetFeeMalformed     = errors.New("temMALFORMED: SetFee has invalid fields")
)

// SetFee is a pseudo-transaction that updates network fee settings.
// This transaction is only valid when generated by consensus (validators).
// Reference: rippled Change.cpp applyFee()
type SetFee struct {
	tx.BaseTx

	// Legacy fields (pre-XRPFees amendment)
	// BaseFee is the base transaction fee (hex string for legacy compatibility)
	BaseFee string `json:"BaseFee,omitempty" xrpl:"BaseFee,omitempty"`

	// ReferenceFeeUnits is the reference fee units (typically 10)
	ReferenceFeeUnits *uint32 `json:"ReferenceFeeUnits,omitempty" xrpl:"ReferenceFeeUnits,omitempty"`

	// ReserveBase is the account reserve in drops
	ReserveBase *uint32 `json:"ReserveBase,omitempty" xrpl:"ReserveBase,omitempty"`

	// ReserveIncrement is the owner reserve increment in drops
	ReserveIncrement *uint32 `json:"ReserveIncrement,omitempty" xrpl:"ReserveIncrement,omitempty"`

	// Modern fields (XRPFees amendment)
	// BaseFeeDrops is the base fee in drops
	BaseFeeDrops string `json:"BaseFeeDrops,omitempty" xrpl:"BaseFeeDrops,omitempty"`

	// ReserveBaseDrops is the account reserve in drops
	ReserveBaseDrops string `json:"ReserveBaseDrops,omitempty" xrpl:"ReserveBaseDrops,omitempty"`

	// ReserveIncrementDrops is the owner reserve increment in drops
	ReserveIncrementDrops string `json:"ReserveIncrementDrops,omitempty" xrpl:"ReserveIncrementDrops,omitempty"`

	// LedgerSequence is the ledger sequence for this fee change
	LedgerSequence *uint32 `json:"LedgerSequence,omitempty" xrpl:"LedgerSequence,omitempty"`
}

// NewSetFee creates a new SetFee pseudo-transaction.
// This should only be used by consensus/validation code.
func NewSetFee() *SetFee {
	// SetFee has empty account (zero account in rippled)
	return &SetFee{
		BaseTx: *tx.NewBaseTx(tx.TypeFee, ""),
	}
}

// TxType returns the transaction type
func (s *SetFee) TxType() tx.Type {
	return tx.TypeFee
}

// Validate validates the SetFee transaction.
// Reference: rippled Change.cpp preflight()
func (s *SetFee) Validate() error {
	// SetFee is a pseudo-transaction - most standard validation is skipped
	// The engine handles pseudo-transaction specific checks

	// Check that either legacy or modern fields are present
	hasLegacy := s.BaseFee != "" || s.ReferenceFeeUnits != nil ||
		s.ReserveBase != nil || s.ReserveIncrement != nil
	hasModern := s.BaseFeeDrops != "" || s.ReserveBaseDrops != "" ||
		s.ReserveIncrementDrops != ""

	// Must have some fee fields
	if !hasLegacy && !hasModern {
		return ErrSetFeeMalformed
	}

	return nil
}

// Flatten returns a flat map of all transaction fields
func (s *SetFee) Flatten() (map[string]any, error) {
	return tx.ReflectFlatten(s)
}

// IsPseudoTransaction returns true as SetFee is a pseudo-transaction
func (s *SetFee) IsPseudoTransaction() bool {
	return true
}

// Apply applies the SetFee transaction to ledger state.
// This creates or updates the FeeSettings singleton entry.
// Reference: rippled Change.cpp applyFee()
func (s *SetFee) Apply(ctx *tx.ApplyContext) tx.Result {
	// Get the fees keylet
	feesKey := keylet.Fees()

	// Check if FeeSettings exists
	exists, err := ctx.View.Exists(feesKey)
	if err != nil {
		return tx.TefINTERNAL
	}

	var feeSettings *sle.FeeSettings

	if exists {
		// Read existing FeeSettings
		data, err := ctx.View.Read(feesKey)
		if err != nil {
			return tx.TefINTERNAL
		}

		feeSettings, err = sle.ParseFeeSettings(data)
		if err != nil {
			return tx.TefINTERNAL
		}
	} else {
		// Create new FeeSettings
		feeSettings = &sle.FeeSettings{}
	}

	// Check if XRPFees amendment is enabled
	// For early ledgers (before XRPFees), we use legacy format
	xrpFeesEnabled := ctx.Config.Rules != nil && ctx.Config.Rules.XRPFeesEnabled()

	if xrpFeesEnabled {
		// Modern format (XRPFees amendment)
		if s.BaseFeeDrops != "" {
			drops, err := parseDropsAmount(s.BaseFeeDrops)
			if err == nil {
				feeSettings.BaseFeeDrops = drops
			}
		}
		if s.ReserveBaseDrops != "" {
			drops, err := parseDropsAmount(s.ReserveBaseDrops)
			if err == nil {
				feeSettings.ReserveBaseDrops = drops
			}
		}
		if s.ReserveIncrementDrops != "" {
			drops, err := parseDropsAmount(s.ReserveIncrementDrops)
			if err == nil {
				feeSettings.ReserveIncrementDrops = drops
			}
		}

		// Clear legacy fields when using modern format
		feeSettings.BaseFee = 0
		feeSettings.ReferenceFeeUnits = 0
		feeSettings.ReserveBase = 0
		feeSettings.ReserveIncrement = 0
	} else {
		// Legacy format (pre-XRPFees)
		if s.BaseFee != "" {
			// BaseFee is a hex string in legacy format
			baseFee, err := parseHexUint64(s.BaseFee)
			if err == nil {
				feeSettings.BaseFee = baseFee
			}
		}
		if s.ReferenceFeeUnits != nil {
			feeSettings.ReferenceFeeUnits = *s.ReferenceFeeUnits
		}
		if s.ReserveBase != nil {
			feeSettings.ReserveBase = *s.ReserveBase
		}
		if s.ReserveIncrement != nil {
			feeSettings.ReserveIncrement = *s.ReserveIncrement
		}
	}

	// Serialize the updated FeeSettings
	data, err := sle.SerializeFeeSettings(feeSettings)
	if err != nil {
		return tx.TefINTERNAL
	}

	// Insert or update the FeeSettings entry
	if exists {
		if err := ctx.View.Update(feesKey, data); err != nil {
			return tx.TefINTERNAL
		}
	} else {
		if err := ctx.View.Insert(feesKey, data); err != nil {
			return tx.TefINTERNAL
		}
	}

	return tx.TesSUCCESS
}

// parseDropsAmount parses a drops amount string to uint64
func parseDropsAmount(s string) (uint64, error) {
	var drops uint64
	_, err := parseUint64(s)
	if err != nil {
		return 0, err
	}
	drops, _ = parseUint64(s)
	return drops, nil
}

// parseHexUint64 parses a hex string to uint64
func parseHexUint64(s string) (uint64, error) {
	var value uint64
	_, err := parseHex(s, &value)
	if err != nil {
		return 0, err
	}
	return value, nil
}

// parseUint64 parses a decimal string to uint64
func parseUint64(s string) (uint64, error) {
	var value uint64
	for _, c := range s {
		if c < '0' || c > '9' {
			return 0, errors.New("invalid digit")
		}
		value = value*10 + uint64(c-'0')
	}
	return value, nil
}

// parseHex parses a hex string into a uint64 pointer
func parseHex(s string, value *uint64) (int, error) {
	*value = 0
	for i, c := range s {
		var digit uint64
		switch {
		case c >= '0' && c <= '9':
			digit = uint64(c - '0')
		case c >= 'a' && c <= 'f':
			digit = uint64(c - 'a' + 10)
		case c >= 'A' && c <= 'F':
			digit = uint64(c - 'A' + 10)
		default:
			return i, errors.New("invalid hex digit")
		}
		*value = *value*16 + digit
	}
	return len(s), nil
}
