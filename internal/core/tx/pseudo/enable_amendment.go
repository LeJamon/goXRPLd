package pseudo

import (
	"errors"

	"github.com/LeJamon/goXRPLd/internal/core/tx"
)

var (
	ErrAmendmentMissing = errors.New("temMALFORMED: EnableAmendment missing amendment hash")
)

func init() {
	tx.Register(tx.TypeAmendment, func() tx.Transaction {
		return &EnableAmendment{BaseTx: *tx.NewBaseTx(tx.TypeAmendment, "")}
	})
}

// EnableAmendment is a pseudo-transaction that enables or tracks amendment voting.
// This transaction is only valid when generated by consensus (validators).
// Reference: rippled Change.cpp applyAmendment()
type EnableAmendment struct {
	tx.BaseTx

	// Amendment is the hash of the amendment being voted on
	Amendment string `json:"Amendment,omitempty" xrpl:"Amendment,omitempty"`

	// LedgerSequence is the ledger sequence for this amendment change
	LedgerSequence *uint32 `json:"LedgerSequence,omitempty" xrpl:"LedgerSequence,omitempty"`
}

// Flags for EnableAmendment pseudo-transactions
const (
	// tfGotMajority indicates the amendment gained majority support
	tfGotMajority uint32 = 0x00010000

	// tfLostMajority indicates the amendment lost majority support
	tfLostMajority uint32 = 0x00020000
)

// TxType returns the transaction type
func (e *EnableAmendment) TxType() tx.Type {
	return tx.TypeAmendment
}

// Validate validates the EnableAmendment transaction.
// Reference: rippled Change.cpp preflight()
func (e *EnableAmendment) Validate() error {
	// Pseudo-transaction: minimal validation
	if e.Amendment == "" {
		return ErrAmendmentMissing
	}
	return nil
}

// Flatten returns a flat map of all transaction fields
func (e *EnableAmendment) Flatten() (map[string]any, error) {
	return tx.ReflectFlatten(e)
}

// IsPseudoTransaction returns true as EnableAmendment is a pseudo-transaction
func (e *EnableAmendment) IsPseudoTransaction() bool {
	return true
}

// Apply applies the EnableAmendment transaction to ledger state.
// Reference: rippled Change.cpp applyAmendment()
//
// TODO: Implement full amendment apply logic for network mode:
//   - Read/create amendments SLE at keylet::amendments()
//   - If tfGotMajority: add amendment hash to sfMajorities array with close time
//   - If tfLostMajority: remove amendment hash from sfMajorities array
//   - If no flags: enable the amendment â€” add to sfAmendments vector,
//     call AmendmentTable.enable(), check if supported (block server if not)
//   - Handle activateTrustLinesToSelfFix() special case
//   - Serialize and update the amendments SLE
func (e *EnableAmendment) Apply(ctx *tx.ApplyContext) tx.Result {
	// Stub: not needed for standalone mode (no validators voting on amendments)
	return tx.TesSUCCESS
}
