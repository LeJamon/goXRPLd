package pseudo

import (
	"github.com/LeJamon/goXRPLd/internal/core/tx"
)

func init() {
	tx.Register(tx.TypeUNLModify, func() tx.Transaction {
		return &UNLModify{BaseTx: *tx.NewBaseTx(tx.TypeUNLModify, "")}
	})
}

// UNLModify is a pseudo-transaction that modifies the Negative UNL.
// This transaction is only valid when generated by consensus on flag ledgers (every 256).
// Reference: rippled Change.cpp applyUNLModify()
type UNLModify struct {
	tx.BaseTx

	// UNLModifyDisabling is 1 to disable a validator, 0 to re-enable
	UNLModifyDisabling *uint8 `json:"UNLModifyDisabling,omitempty" xrpl:"UNLModifyDisabling,omitempty"`

	// LedgerSequence is the ledger sequence (must match current ledger)
	LedgerSequence *uint32 `json:"LedgerSequence,omitempty" xrpl:"LedgerSequence,omitempty"`

	// UNLModifyValidator is the public key of the validator to modify
	UNLModifyValidator string `json:"UNLModifyValidator,omitempty" xrpl:"UNLModifyValidator,omitempty"`
}

// TxType returns the transaction type
func (u *UNLModify) TxType() tx.Type {
	return tx.TypeUNLModify
}

// Validate validates the UNLModify transaction.
// Reference: rippled Change.cpp preflight()
func (u *UNLModify) Validate() error {
	// Pseudo-transaction: minimal validation
	// TODO: Check featureNegativeUNL is enabled (requires Rules access in Validate)
	return nil
}

// Flatten returns a flat map of all transaction fields
func (u *UNLModify) Flatten() (map[string]any, error) {
	return tx.ReflectFlatten(u)
}

// IsPseudoTransaction returns true as UNLModify is a pseudo-transaction
func (u *UNLModify) IsPseudoTransaction() bool {
	return true
}

// Apply applies the UNLModify transaction to ledger state.
// Reference: rippled Change.cpp applyUNLModify()
//
// TODO: Implement full UNL modify logic for network mode:
//   - Verify this is a flag ledger: isFlagLedger(view.seq()) — i.e. (seq % 256 == 0)
//   - Validate required fields: UNLModifyDisabling (0 or 1), LedgerSequence, UNLModifyValidator
//   - Verify LedgerSequence matches current ledger sequence
//   - Validate UNLModifyValidator is a valid public key
//   - Read/create negative UNL SLE at keylet::negativeUNL()
//     (needs keylet.NegativeUNL() — not yet implemented)
//   - If disabling (UNLModifyDisabling == 1):
//     - Must not already have a ValidatorToDisable
//     - Must not conflict with ValidatorToReEnable
//     - Must not already be in the DisabledValidators array
//     - Set sfValidatorToDisable on the SLE
//   - If re-enabling (UNLModifyDisabling == 0):
//     - Must not already have a ValidatorToReEnable
//     - Must not conflict with ValidatorToDisable
//     - Must already be in the DisabledValidators array
//     - Set sfValidatorToReEnable on the SLE
//   - Update the negative UNL SLE
func (u *UNLModify) Apply(ctx *tx.ApplyContext) tx.Result {
	// Stub: not needed for standalone mode (no validators in negative UNL)
	return tx.TesSUCCESS
}
